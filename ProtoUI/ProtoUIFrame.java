package protoui;

import JSONParser.JSONArray;
import JSONParser.JSONArrayNode;
import JSONParser.JSONBoolean;
import JSONParser.JSONList;
import JSONParser.JSONNode;
import JSONParser.JSONNull;
import JSONParser.JSONNumber;
import JSONParser.JSONObject;
import JSONParser.JSONObjectNode;
import JSONParser.JSONReader;
import JSONParser.JSONString;
import JSONParser.JSONValue;
import JSONParser.MalformedJSONException;
import java.awt.Color;
import java.awt.Cursor;
import java.awt.Font;
import java.awt.Point;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.MouseEvent;
import java.io.BufferedInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.HashMap;
import java.util.concurrent.ExecutionException;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.JFileChooser;
import javax.swing.JMenu;
import javax.swing.JMenuItem;
import javax.swing.JOptionPane;
import javax.swing.JPopupMenu;
import javax.swing.SwingWorker;
import javax.swing.UIManager;
import javax.swing.filechooser.FileNameExtensionFilter;
import javax.swing.text.BadLocationException;
import javax.swing.text.DefaultHighlighter.DefaultHighlightPainter;
import javax.swing.tree.DefaultTreeModel;
import javax.swing.tree.TreePath;

/**
 *
 * @author RÃ©gis M. LeClerc
 */
public class ProtoUIFrame extends javax.swing.JFrame {
    private static final long serialVersionUID = 1L;
    private final String ApplicationName = "Antidote JSON Viewer";
    private final ProtoUIFrame This = this; // when accessing the UI from other threads


    private final JSONReader JSONData;
    private CustomMutableTreeNode TreeRoot;
    private final DefaultTreeModel TreeModel;
    JSONTreeCellRenderer JSONTreeRenderer;
    private int DisplayableStringChars = 40;

    private final JFileChooser OpenFileDialog;
    final DialogAbout AboutDlg;
    final DialogLoadProgress DialogFileLoadProgress;
    
    // Object Broker... sort of...
    public static final HashMap <String,Object> ConfigValues = new HashMap<>();

    /**
     * Creates new form ProtoUIFrame
     * 
     */
    public ProtoUIFrame() {
        initComponents();
        
        // Setup the JSONTree
        (JSONData = new JSONReader()).initTree(new JSONObject());                        
        (TreeModel = new DefaultTreeModel(TreeRoot = buildNode("Empty file",JSONData.getTree()))).setRoot(TreeRoot);
        JSONTree.setModel(TreeModel);
        JSONTree.setCellRenderer(JSONTreeRenderer = new JSONTreeCellRenderer());

        // Dialogs are created here instead of creating them on the fly when they're needed. This adda persistance...
        AboutDlg = new DialogAbout(this,true); // The "Info" dialog
        
        OpenFileDialog = new JFileChooser(); // The File-Open dialog
        // Add some extensions to it:
        OpenFileDialog.addChoosableFileFilter(new FileNameExtensionFilter("JSON files"  , "json"  )); // *.json
        OpenFileDialog.addChoosableFileFilter(new FileNameExtensionFilter("Result files", "result")); // *.result
        
        DialogFileLoadProgress = new DialogLoadProgress(this,true); // File Load Progress
        
        // initialise default configuration colors:
        ConfigValues.put("JSONTreeBackgroundNonSelectionColor", Color.DARK_GRAY   );
        ConfigValues.put("JSONTreeBackground"                 , Color.DARK_GRAY   );
        ConfigValues.put("JSONTreeBackgroundNonSelectionColor", Color.DARK_GRAY   );
        ConfigValues.put("JSONTreeBackgroundSelectionColor"   , new Color(0,0,0,0));
        ConfigValues.put("JSONTreeTextNonSelectionColor"      , Color.LIGHT_GRAY  );
        ConfigValues.put("JSONTreeTextSelectionColor"         , Color.WHITE       );
        ConfigValues.put("JSONContentForeground"              , Color.WHITE       );
        ConfigValues.put("JSONContentBackground"              , Color.DARK_GRAY   );
        ConfigValues.put("JSONContentSelectionBackground"     , Color.ORANGE      );
        ConfigValues.put("JSONContentFont"                    , new Font(Font.MONOSPACED,Font.BOLD,12));
        
        applyConfiguration();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        PanelContents = new javax.swing.JPanel();
        Splitter = new javax.swing.JSplitPane();
        TreeSplitPanel = new javax.swing.JPanel();
        ScrollPaneTree = new javax.swing.JScrollPane();
        JSONTree = new javax.swing.JTree();
        PanelFind = new javax.swing.JPanel();
        LabelFind = new javax.swing.JLabel();
        TextToFind = new javax.swing.JTextField();
        ButtonHideFindPanel = new javax.swing.JButton();
        ButtonSearch = new javax.swing.JButton();
        ContentSplitPanel = new javax.swing.JPanel();
        ScrollPaneContent = new javax.swing.JScrollPane();
        JSONContent = new javax.swing.JTextArea();
        PanelContentFind = new javax.swing.JPanel();
        LabelContentFind = new javax.swing.JLabel();
        ContentFindWhat = new javax.swing.JTextField();
        ContentButtonSearch = new javax.swing.JButton();
        ButtonHideContentSearch = new javax.swing.JButton();
        MainMenuBar = new javax.swing.JMenuBar();
        MenuFile = new javax.swing.JMenu();
        jMenuItem3 = new javax.swing.JMenuItem();
        Open = new javax.swing.JMenuItem();
        jMenuItem2 = new javax.swing.JMenuItem();
        jMenuItem1 = new javax.swing.JMenuItem();
        Info = new javax.swing.JMenuItem();
        jSeparator1 = new javax.swing.JPopupMenu.Separator();
        Quit = new javax.swing.JMenuItem();
        MenuEdit = new javax.swing.JMenu();
        Find = new javax.swing.JMenuItem();
        ContentActions = new javax.swing.JMenu();
        ContentFind = new javax.swing.JMenuItem();
        JumpToBegin = new javax.swing.JMenuItem();
        JumpToEnd = new javax.swing.JMenuItem();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("Antidote JSON Viewer");
        setLocationByPlatform(true);
        setPreferredSize(new java.awt.Dimension(640, 480));

        Splitter.setBorder(null);
        Splitter.setDividerLocation(240);
        Splitter.setDividerSize(4);

        ScrollPaneTree.setBorder(null);

        JSONTree.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                JSONTreeMouseClicked(evt);
            }
        });
        JSONTree.addTreeSelectionListener(new javax.swing.event.TreeSelectionListener() {
            public void valueChanged(javax.swing.event.TreeSelectionEvent evt) {
                JSONTreeValueChanged(evt);
            }
        });
        ScrollPaneTree.setViewportView(JSONTree);

        PanelFind.setBorder(javax.swing.BorderFactory.createBevelBorder(0));

        LabelFind.setLabelFor(TextToFind);
        LabelFind.setText("Find:");

        TextToFind.setAlignmentX(0.0F);
        TextToFind.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                execSearch(evt);
            }
        });

        ButtonHideFindPanel.setIcon(new javax.swing.ImageIcon(getClass().getResource("/protoui/Images/down-arrow-circle-hi.png"))); // NOI18N
        ButtonHideFindPanel.setToolTipText("Hide the Node Search panel");
        ButtonHideFindPanel.setBorder(null);
        ButtonHideFindPanel.setContentAreaFilled(false);
        ButtonHideFindPanel.setCursor(new java.awt.Cursor(java.awt.Cursor.HAND_CURSOR));
        ButtonHideFindPanel.setDefaultCapable(false);
        ButtonHideFindPanel.setIconTextGap(0);
        ButtonHideFindPanel.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                ButtonHideFindPanelActionPerformed(evt);
            }
        });

        ButtonSearch.setIcon(new javax.swing.ImageIcon(getClass().getResource("/protoui/Images/icon_search.png"))); // NOI18N
        ButtonSearch.setToolTipText("Search the string in the tree");
        ButtonSearch.setActionCommand("Search");
        ButtonSearch.setAlignmentY(0.0F);
        ButtonSearch.setBorderPainted(false);
        ButtonSearch.setContentAreaFilled(false);
        ButtonSearch.setIconTextGap(0);
        ButtonSearch.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                ButtonSearchActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout PanelFindLayout = new javax.swing.GroupLayout(PanelFind);
        PanelFind.setLayout(PanelFindLayout);
        PanelFindLayout.setHorizontalGroup(
            PanelFindLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(PanelFindLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(LabelFind)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(TextToFind)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(ButtonSearch, javax.swing.GroupLayout.PREFERRED_SIZE, 28, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(18, 18, 18)
                .addComponent(ButtonHideFindPanel)
                .addContainerGap())
        );
        PanelFindLayout.setVerticalGroup(
            PanelFindLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(ButtonSearch, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.PREFERRED_SIZE, 0, Short.MAX_VALUE)
            .addGroup(PanelFindLayout.createSequentialGroup()
                .addGroup(PanelFindLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(TextToFind, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(LabelFind))
                .addGap(0, 0, Short.MAX_VALUE))
            .addGroup(PanelFindLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(ButtonHideFindPanel)
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        PanelFind.setVisible(false);

        javax.swing.GroupLayout TreeSplitPanelLayout = new javax.swing.GroupLayout(TreeSplitPanel);
        TreeSplitPanel.setLayout(TreeSplitPanelLayout);
        TreeSplitPanelLayout.setHorizontalGroup(
            TreeSplitPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(PanelFind, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
            .addComponent(ScrollPaneTree, javax.swing.GroupLayout.Alignment.TRAILING)
        );
        TreeSplitPanelLayout.setVerticalGroup(
            TreeSplitPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(TreeSplitPanelLayout.createSequentialGroup()
                .addComponent(ScrollPaneTree, javax.swing.GroupLayout.DEFAULT_SIZE, 414, Short.MAX_VALUE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(PanelFind, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
        );

        Splitter.setLeftComponent(TreeSplitPanel);

        ScrollPaneContent.setBorder(null);

        JSONContent.setEditable(false);
        JSONContent.setColumns(20);
        JSONContent.setRows(5);
        JSONContent.setAlignmentX(0.0F);
        JSONContent.setAlignmentY(0.0F);
        JSONContent.setBorder(null);
        ScrollPaneContent.setViewportView(JSONContent);

        PanelContentFind.setBorder(javax.swing.BorderFactory.createBevelBorder(0));

        LabelContentFind.setLabelFor(ContentFindWhat);
        LabelContentFind.setText("Find:");

        ContentFindWhat.addCaretListener(new javax.swing.event.CaretListener() {
            public void caretUpdate(javax.swing.event.CaretEvent evt) {
                ContentFindWhatCaretUpdate(evt);
            }
        });
        ContentFindWhat.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                ContentFindActionPerformed(evt);
            }
        });

        ContentButtonSearch.setIcon(new javax.swing.ImageIcon(getClass().getResource("/protoui/Images/icon_search.png"))); // NOI18N
        ContentButtonSearch.setToolTipText("Search the string in the Content");
        ContentButtonSearch.setAlignmentY(0.0F);
        ContentButtonSearch.setBorder(null);
        ContentButtonSearch.setBorderPainted(false);
        ContentButtonSearch.setContentAreaFilled(false);
        ContentButtonSearch.setCursor(new java.awt.Cursor(java.awt.Cursor.HAND_CURSOR));
        ContentButtonSearch.setIconTextGap(0);
        ContentButtonSearch.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                ContentButtonSearchActionPerformed(evt);
            }
        });

        ButtonHideContentSearch.setIcon(new javax.swing.ImageIcon(getClass().getResource("/protoui/Images/down-arrow-circle-hi.png"))); // NOI18N
        ButtonHideContentSearch.setToolTipText("Hide the Content Search panel");
        ButtonHideContentSearch.setBorder(null);
        ButtonHideContentSearch.setBorderPainted(false);
        ButtonHideContentSearch.setContentAreaFilled(false);
        ButtonHideContentSearch.setDefaultCapable(false);
        ButtonHideContentSearch.setFocusPainted(false);
        ButtonHideContentSearch.setFocusable(false);
        ButtonHideContentSearch.setRequestFocusEnabled(false);
        ButtonHideContentSearch.setVerifyInputWhenFocusTarget(false);
        ButtonHideContentSearch.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                ButtonHideContentSearchActionPerformed(evt);
            }
        });

        PanelContentFind.setVisible(false);

        javax.swing.GroupLayout PanelContentFindLayout = new javax.swing.GroupLayout(PanelContentFind);
        PanelContentFind.setLayout(PanelContentFindLayout);
        PanelContentFindLayout.setHorizontalGroup(
            PanelContentFindLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(PanelContentFindLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(LabelContentFind)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(ContentFindWhat)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(ContentButtonSearch)
                .addGap(18, 18, 18)
                .addComponent(ButtonHideContentSearch)
                .addContainerGap())
        );
        PanelContentFindLayout.setVerticalGroup(
            PanelContentFindLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, PanelContentFindLayout.createSequentialGroup()
                .addComponent(ButtonHideContentSearch)
                .addGap(8, 8, 8))
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, PanelContentFindLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                .addComponent(ContentFindWhat, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addComponent(LabelContentFind))
            .addComponent(ContentButtonSearch, javax.swing.GroupLayout.Alignment.TRAILING)
        );

        javax.swing.GroupLayout ContentSplitPanelLayout = new javax.swing.GroupLayout(ContentSplitPanel);
        ContentSplitPanel.setLayout(ContentSplitPanelLayout);
        ContentSplitPanelLayout.setHorizontalGroup(
            ContentSplitPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(ScrollPaneContent, javax.swing.GroupLayout.PREFERRED_SIZE, 0, Short.MAX_VALUE)
            .addComponent(PanelContentFind, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
        );
        ContentSplitPanelLayout.setVerticalGroup(
            ContentSplitPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(ContentSplitPanelLayout.createSequentialGroup()
                .addComponent(ScrollPaneContent, javax.swing.GroupLayout.DEFAULT_SIZE, 414, Short.MAX_VALUE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(PanelContentFind, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
        );

        Splitter.setRightComponent(ContentSplitPanel);

        javax.swing.GroupLayout PanelContentsLayout = new javax.swing.GroupLayout(PanelContents);
        PanelContents.setLayout(PanelContentsLayout);
        PanelContentsLayout.setHorizontalGroup(
            PanelContentsLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(PanelContentsLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(Splitter, javax.swing.GroupLayout.DEFAULT_SIZE, 394, Short.MAX_VALUE)
                .addContainerGap())
        );
        PanelContentsLayout.setVerticalGroup(
            PanelContentsLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(PanelContentsLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(Splitter))
        );

        MenuFile.setText("File");

        jMenuItem3.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_N, java.awt.event.InputEvent.CTRL_MASK));
        jMenuItem3.setText("New");
        MenuFile.add(jMenuItem3);

        Open.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_O, java.awt.event.InputEvent.CTRL_MASK));
        Open.setText("Open...");
        Open.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                OpenActionPerformed(evt);
            }
        });
        MenuFile.add(Open);

        jMenuItem2.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_S, java.awt.event.InputEvent.CTRL_MASK));
        jMenuItem2.setText("Save");
        MenuFile.add(jMenuItem2);

        jMenuItem1.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_S, java.awt.event.InputEvent.SHIFT_MASK | java.awt.event.InputEvent.CTRL_MASK));
        jMenuItem1.setText("Save as...");
        MenuFile.add(jMenuItem1);

        Info.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_PERIOD, java.awt.event.InputEvent.CTRL_MASK));
        Info.setText("About...");
        Info.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                InfoActionPerformed(evt);
            }
        });
        MenuFile.add(Info);
        MenuFile.add(jSeparator1);

        Quit.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_Q, java.awt.event.InputEvent.CTRL_MASK));
        Quit.setText("Quit");
        Quit.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                QuitActionPerformed(evt);
            }
        });
        MenuFile.add(Quit);

        MainMenuBar.add(MenuFile);

        MenuEdit.setText("Edit");

        Find.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_F3, 0));
        Find.setText("Find / Find Next");
        Find.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                FindActionPerformed(evt);
            }
        });
        MenuEdit.add(Find);

        ContentActions.setText("Content Actions");

        ContentFind.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_F3, java.awt.event.InputEvent.SHIFT_MASK));
        ContentFind.setText("Find in Content");
        ContentFind.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                ContentFindActionPerformed(evt);
            }
        });
        ContentActions.add(ContentFind);

        JumpToBegin.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_B, java.awt.event.InputEvent.CTRL_MASK));
        JumpToBegin.setText("Jump to Begin");
        JumpToBegin.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                JumpToBeginActionPerformed(evt);
            }
        });
        ContentActions.add(JumpToBegin);

        JumpToEnd.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_E, java.awt.event.InputEvent.CTRL_MASK));
        JumpToEnd.setText("Jump To End");
        JumpToEnd.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                JumpToEndActionPerformed(evt);
            }
        });
        ContentActions.add(JumpToEnd);

        MenuEdit.add(ContentActions);

        MainMenuBar.add(MenuEdit);

        setJMenuBar(MainMenuBar);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(PanelContents, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(PanelContents, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void applyConfiguration() {
        // Color definitions
        JSONTreeRenderer.setBackgroundNonSelectionColor((Color)ConfigValues.get("JSONTreeBackgroundNonSelectionColor"));
        JSONTree.setBackground                         ((Color)ConfigValues.get("JSONTreeBackground"                 ));
        JSONTreeRenderer.setBackgroundSelectionColor   ((Color)ConfigValues.get("JSONTreeBackgroundSelectionColor"   ));
        JSONTreeRenderer.setTextNonSelectionColor      ((Color)ConfigValues.get("JSONTreeTextNonSelectionColor"      ));
        JSONTreeRenderer.setTextSelectionColor         ((Color)ConfigValues.get("JSONTreeTextSelectionColor"         ));
        JSONContent.setForeground                      ((Color)ConfigValues.get("JSONContentForeground"              ));
        JSONContent.setBackground                      ((Color)ConfigValues.get("JSONContentBackground"              ));
        JSONContent.setFont                            ((Font )ConfigValues.get("JSONContentFont"                    ));
    }
    
    private void QuitActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_QuitActionPerformed
        dispose();
    }//GEN-LAST:event_QuitActionPerformed

    private void OpenActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_OpenActionPerformed
        if((OpenFileDialog.showOpenDialog(this)) == JFileChooser.APPROVE_OPTION) {
            final File   TheFile     = OpenFileDialog.getSelectedFile();
            final String FileName = TheFile.getAbsoluteFile().toString();
            final long   FileSize = TheFile.length();

            // Prepare the Load Progress Dialog for display
            DialogFileLoadProgress.LabelNameLoadProgress.setText(FileName);
            DialogFileLoadProgress.BarFileLoadProgress.setValue(0);
            DialogFileLoadProgress.pack();
            DialogFileLoadProgress.setLocationRelativeTo(this); // center

            JSONData.setReadCallback(new Runnable() {
                        int PrevProgress = 0;

                        @Override
                        public synchronized void run() {
                            long CarPos = JSONData.getCarPos();
                            int progress = FileSize == 0 ? 0 : ((Long) (100 - (((FileSize - CarPos) * 100) / FileSize))).intValue();

                            if (progress != PrevProgress) {
                                DialogFileLoadProgress.BarFileLoadProgress.setValue(progress);
                                DialogFileLoadProgress.BarFileLoadProgress.setString(String.valueOf(progress) + "%");
                                PrevProgress = progress;
                            }
                        }
                    });
            // Create the load task
            SwingWorker task = new SwingWorker<JSONObject,Void>() {
                @Override
                protected synchronized JSONObject doInBackground() throws MalformedJSONException, IOException {
                    DialogFileLoadProgress.setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));
                    JSONData.readJSONFromStream(new BufferedInputStream(new FileInputStream(TheFile)));
                    return JSONData.getTree();
                }

                @Override
                public void done() {
                    try {
                        DialogFileLoadProgress.setVisible(false);
                        JSONData.setReadCallback(null);
                        get();
                    } catch(InterruptedException | ExecutionException e) {
                        JOptionPane.showMessageDialog(This,e.getMessage(),"Error",JOptionPane.ERROR_MESSAGE);
                    }
                }
            };

            task.execute();
            DialogFileLoadProgress.setVisible(true);
            if(JSONData.getTree() != null) {
                This.setTitle(ApplicationName + " - " + FileName);
                TreeRoot = new CustomMutableTreeNode(FileName);
                TreeRoot = buildNode(FileName,JSONData.getTree());
                
                TreeModel.setRoot(TreeRoot);
                JSONTree.setModel(TreeModel);
                JSONTree.treeDidChange();
                JSONTree.setSelectionPath(new TreePath(TreeRoot)); // select the root
            } else repaint();

        }
    }//GEN-LAST:event_OpenActionPerformed

    private void InfoActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_InfoActionPerformed
                AboutDlg.setLocationRelativeTo(this); // center position to UI_Main 
                AboutDlg.setVisible(true); // display the modal dialog box        
    }//GEN-LAST:event_InfoActionPerformed

    private void FindActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_FindActionPerformed
        // if the Find panel is hidden, show it, otherwise perform a FindNext()
        if(!PanelFind.isVisible() || TextToFind.getText().isEmpty()) {
            PanelFind.setVisible(true);
            TextToFind.grabFocus();
        } else execSearch(evt);
    }//GEN-LAST:event_FindActionPerformed

    private void updateJSONContentPanel() {
                CustomMutableTreeNode node = (CustomMutableTreeNode)JSONTree.getLastSelectedPathComponent();

        if (node != null) {
            JSONValue TheObject = node.getValuePointer();
            
            // another very daring style of switch() with the ternary operator to avoid using a temporary variable
            JSONContent.setText(
                    TheObject instanceof JSONObject  ? node.getUserObject().toString() + " = " + getObjectTreeString((JSONObject)TheObject,0) :
                    TheObject instanceof JSONArray   ? node.getUserObject().toString() + " = " + getArrayTreeString ((JSONArray )TheObject,0) :
                    TheObject instanceof JSONString  ? ((JSONString)TheObject).getValue() :
                                                       TheObject.getString(0) + "\n"
            );
            // force caret to the beginning of JSONContent, as setting the text modifies the caret accordingly,
            // so the focus is at the end of the last line of the displayed text, which is annoying when displaying
            // very long lines or very long strings
            JSONContent.setCaretPosition(0);
        }
    }
    
    private void JSONTreeValueChanged(javax.swing.event.TreeSelectionEvent evt) {//GEN-FIRST:event_JSONTreeValueChanged
        updateJSONContentPanel();
    }//GEN-LAST:event_JSONTreeValueChanged

    private void JumpToBeginActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_JumpToBeginActionPerformed
        JSONContent.setCaretPosition(0);
    }//GEN-LAST:event_JumpToBeginActionPerformed

    private void JumpToEndActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_JumpToEndActionPerformed
        JSONContent.setCaretPosition(JSONContent.getText().length());
    }//GEN-LAST:event_JumpToEndActionPerformed

    private void ButtonHideContentSearchActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_ButtonHideContentSearchActionPerformed
        this.PanelContentFind.setVisible(false);
    }//GEN-LAST:event_ButtonHideContentSearchActionPerformed

    private void ContentFindActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_ContentFindActionPerformed
        if(!PanelContentFind.isVisible() || ContentFindWhat.getText().isEmpty()) {
            PanelContentFind.setVisible(true);
            ContentFindWhat.grabFocus();
        } else ContentButtonSearchActionPerformed(evt);        
    }//GEN-LAST:event_ContentFindActionPerformed

    private void ContentButtonSearchExecute() {
        String Search = ContentFindWhat.getText().toLowerCase();
        JSONContent.getHighlighter().removeAllHighlights(); // if previous search
        if(!Search.isEmpty()) {
            String Text = JSONContent.getText().toLowerCase();
            int Start = 0;
            int Hits = 0;

            while(Start < Text.length() && Text.substring(Start).contains(Search)) {
                int Next = Text.substring(Start).indexOf(Search);
                Hits++;
                Start += Next;
                try {
                    DefaultHighlightPainter highlightPainter = new DefaultHighlightPainter((Color)ConfigValues.get("JSONContentSelectionBackground"));
                    JSONContent.getHighlighter().addHighlight(Start, Start + Search.length(), highlightPainter);        

                    //selectContent(Start,Start + Search.length());
                } catch (BadLocationException ex) {
                    Logger.getLogger(ProtoUIFrame.class.getName()).log(Level.SEVERE, null, ex);
                }
                Start++;
            }        
            if(Hits == 0) UIManager.getLookAndFeel().provideErrorFeedback(this);
            ContentFindWhat.requestFocus();
        }
    }
    
    private void ContentButtonSearchActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_ContentButtonSearchActionPerformed
        // Perform search
        ContentButtonSearchExecute();
    }//GEN-LAST:event_ContentButtonSearchActionPerformed

    private void ButtonSearchActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_ButtonSearchActionPerformed
        execSearch(evt);
    }//GEN-LAST:event_ButtonSearchActionPerformed

    private void ButtonHideFindPanelActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_ButtonHideFindPanelActionPerformed
        PanelFind.setVisible(false);
    }//GEN-LAST:event_ButtonHideFindPanelActionPerformed

    private void execSearch(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_execSearch
        String FindWhat = TextToFind.getText();
        if(FindWhat.isEmpty()) UIManager.getLookAndFeel().provideErrorFeedback(this);
        else { /* check if a node is selected and put it in SearchRoot */
            CustomMutableTreeNode SearchRoot = JSONTree.getSelectionPath() == null ?
            null : // No selection
            (CustomMutableTreeNode)JSONTree.getSelectionPath().getLastPathComponent();
            CustomMutableTreeNode WhatWasFound = searchNode(FindWhat,SearchRoot); // perform the search
            if(WhatWasFound != null && (WhatWasFound != SearchRoot)) {
                JSONTree.setSelectionPath(new TreePath(WhatWasFound.getPath()));
                JSONTree.scrollPathToVisible(JSONTree.getSelectionPath());
                JSONTree.grabFocus();
            } else UIManager.getLookAndFeel().provideErrorFeedback(this);
        }
    }//GEN-LAST:event_execSearch

    private void ContentFindWhatCaretUpdate(javax.swing.event.CaretEvent evt) {//GEN-FIRST:event_ContentFindWhatCaretUpdate
        // TODO add your handling code here:
                ContentButtonSearchExecute();

    }//GEN-LAST:event_ContentFindWhatCaretUpdate
    
     /**
     * Specialised class handling the selection of the popup context menu
     * so the selected node is directly available to the function.
     */
    private class TreePopupActionListener implements ActionListener {
        CustomMutableTreeNode TheNode = null;
        Point Location;
        TreePopupActionListener(CustomMutableTreeNode sel) {
            super();
            TheNode = sel;
        }
        
        private void renumArray(CustomMutableTreeNode TheNode) {
            CustomMutableTreeNode cursor = (CustomMutableTreeNode)TheNode.getFirstChild();
            int NodeNumber = 0;
            do {
                cursor.setUserObject('[' + Integer.toString(NodeNumber++) + ']');
            } while((cursor = (CustomMutableTreeNode)cursor.getNextSibling()) != null);
        }
        
        private void refreshNode(CustomMutableTreeNode TheNode) {
            ((DefaultTreeModel)JSONTree.getModel()).reload(TheNode);
            JSONTree.setSelectionPath(new TreePath(TheNode.getPath()));
            JSONTree.expandPath(JSONTree.getAnchorSelectionPath());
        }
        
        private void addNewNode(JSONValue NewValue) {
            JSONValue VP = TheNode.ValuePointer;
            JSONNode NewNode;
            CustomMutableTreeNode aPath;

            if(VP instanceof JSONObject) {
                NewNode = ((JSONList)VP).insertNode(new JSONObjectNode("NoName",NewValue));
                TheNode.insert(aPath = new CustomMutableTreeNode(NewNode.getName(),NewValue),0);
            } else {
                NewNode = ((JSONList)VP).insertNode(new JSONArrayNode(NewValue));
                TheNode.insert(aPath = new CustomMutableTreeNode("",NewValue),0);
                renumArray(TheNode);
            }
            NewNode.getValue().setParent(VP);
            refreshNode(TheNode);
            JSONTree.setSelectionPath(new TreePath(aPath.getPath()));
        }
        
        @Override
        public void actionPerformed(ActionEvent e) {
            if(TheNode !=null) {
                JSONValue VP = TheNode.ValuePointer;                
                                
                switch(e.getActionCommand()) {
                    case "EDSTR"  :
                        DialogEditString DlgEdit = new DialogEditString(This, (JSONString) VP);
                        DlgEdit.setLocationRelativeTo(JSONTree);
                        DlgEdit.setVisible(true);
                        if(DlgEdit.getReturnStatus() == DialogEditString.RET_OK) {
                            ((JSONString)VP).setValue(DlgEdit.getText());
                            ((DefaultTreeModel)JSONTree.getModel()).nodeChanged(TheNode);
                        }
                        break;
                    case "EDNUM"  :
                        DialogEditNumber DlgEditNum = new DialogEditNumber(This, (JSONNumber) VP);
                        DlgEditNum.setLocationRelativeTo(JSONTree);
                        DlgEditNum.setVisible(true);
                        if(DlgEditNum.getReturnStatus() == DialogEditString.RET_OK) {
                            ((JSONNumber)VP).setValue(DlgEditNum.getText());
                            ((DefaultTreeModel)JSONTree.getModel()).nodeChanged(TheNode);
                        }                        break;
                    case "INVERT" :
                        ((JSONBoolean)VP).setValue(!((JSONBoolean)VP).getValue());
                        ((DefaultTreeModel)JSONTree.getModel()).nodeChanged(TheNode);
                        break;
                        
                    case "ADDOBJ" : this.addNewNode(new JSONObject()); break;                        
                    case "ADDARR" : this.addNewNode(new JSONArray()); break;
                    case "ADDNUL" : this.addNewNode(new JSONNull()); break;
                    case "ADDSTR" : this.addNewNode(new JSONString("")); break;
                    case "ADDNUM" : this.addNewNode(new JSONNumber("0.0")); break;
                    case "ADDBOO" : this.addNewNode(new JSONBoolean(false)); break;
                    case "DEL" :
                        CustomMutableTreeNode NewSel = (CustomMutableTreeNode)TheNode.getParent();
                        JSONValue ParentNode = NewSel.getValuePointer();
                        TheNode.removeFromParent();
                        TheNode = NewSel;
                        ((JSONList)ParentNode).getNode(VP).remove();
                        if(ParentNode instanceof JSONArray && ParentNode.getValue() != null) this.renumArray(TheNode);
                        refreshNode(TheNode);
                        break;
                        
                    case "REN" :
                        JSONNode ON = ((JSONList)VP.getParent()).getNode(VP); // get the JSONObjectNode holding the name
                        DialogRenameNode Dlg = new DialogRenameNode(This,true);
                        Dlg.setLocationRelativeTo(JSONTree);
                        Dlg.NewNodeName.setText(((JSONObjectNode)ON).getName());
                        Dlg.setVisible(true);
                        if(Dlg.getReturnStatus() == DialogRenameNode.RET_OK) {
                            String NewNodeName = Dlg.NewNodeName.getText();
                            if(!NewNodeName.isEmpty()) {
                                ((JSONObjectNode)ON).setName(NewNodeName);
                                TheNode.setUserObject(NewNodeName);
                                ((DefaultTreeModel)JSONTree.getModel()).nodeChanged(TheNode);
                            }
                            Dlg.dispose();
                        }
                        break;
                } // switch(e.getActionCommand)
                updateJSONContentPanel();
            } // if(TheNode != null)
        } // ActionPerformed
    } // TreePopupActionListener

    private JMenuItem AddMenuItem(String label,String cmd) {
        JMenuItem Item = new JMenuItem(label);
        Item.setActionCommand(cmd);
        return Item;
    }
        
    private void JSONTreeMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_JSONTreeMouseClicked
        // create popup menu on right click on a node
        CustomMutableTreeNode selectedNode;
        if(evt.getButton() == MouseEvent.BUTTON3){
            TreePath pathForLocation = JSONTree.getPathForLocation(evt.getX(), evt.getY());
            if(pathForLocation != null){
                JSONTree.setSelectionPath(pathForLocation); // force node selection and ContentPane update
                selectedNode = (CustomMutableTreeNode)pathForLocation.getLastPathComponent();
                JSONValue VP = selectedNode.getValuePointer();
                
                JPopupMenu popup = new JPopupMenu();
                popup.setLightWeightPopupEnabled(true);
                TreePopupActionListener PopListener = new TreePopupActionListener(selectedNode);
                PopListener.Location = evt.getPoint();

                if(VP instanceof JSONString) popup.add(AddMenuItem("Edit...","EDSTR")).addActionListener(PopListener);
                else if(VP instanceof JSONNumber) popup.add(AddMenuItem("Edit...","EDNUM")).addActionListener(PopListener);
                else if(VP instanceof JSONBoolean) popup.add(AddMenuItem("Invert","INVERT")).addActionListener(PopListener);
                else if(VP instanceof JSONList) {
                    JMenu sm = new JMenu("Add");
                    sm.add(AddMenuItem("Object" ,"ADDOBJ")).addActionListener(PopListener);
                    sm.add(AddMenuItem("Array"  ,"ADDARR" )).addActionListener(PopListener);
                    sm.addSeparator();
                    sm.add(AddMenuItem("String" ,"ADDSTR")).addActionListener(PopListener);
                    sm.add(AddMenuItem("Number" ,"ADDNUM")).addActionListener(PopListener);
                    sm.add(AddMenuItem("Boolean","ADDBOO"  )).addActionListener(PopListener);
                    sm.addSeparator();
                    sm.add(AddMenuItem("Null"   ,"ADDNUL"  )).addActionListener(PopListener);
                    popup.add(sm).addActionListener(PopListener);
                }
                
                // Rename option only if it's a child of a JSONObject
                if((VP.getParent() != null) && VP.getParent() instanceof JSONObject)
                        popup.add(AddMenuItem("Rename...","REN")).addActionListener(PopListener);
                // Delete option if it's not the root
                if(VP.getParent() != null) popup.add(AddMenuItem("Delete","DEL")).addActionListener(PopListener);
                popup.show(evt.getComponent(),evt.getX(),evt.getY());
            }// else selectedNode = null;
        }
    }//GEN-LAST:event_JSONTreeMouseClicked

    // Support functions to display text-trees in the JSONContent area when an Object or an Array is selected
    // it'ReturnString the same as getIndent from the JSONValue object, with a vertical bar at the beginning
    private String getTreeIndent(int IndentLevel) {
        String ret = "";
        while(IndentLevel-- > 0) ret += "|   ";
        return ret;
    } // getIndent()
    
    private String getTreeValue(JSONValue Value,int IndentLevel) {
        String s = "";
        
        if(Value instanceof JSONObject) s = getObjectTreeString((JSONObject) Value,IndentLevel + 1);
        else if (Value instanceof JSONArray) s = getArrayTreeString((JSONArray) Value,IndentLevel + 1);
        else if(Value instanceof JSONString) {
            int l = ((JSONString)Value).getValue().length();
            s = "String[" + Integer.toString(l) + "] = \"";
            String TS = String.valueOf(((JSONString)Value).escapeLeft(l < DisplayableStringChars ? l : DisplayableStringChars));
            if(l > DisplayableStringChars) TS += "\u2026"; // append ellipsis if truncated
            s += TS + '\"';
        } else s += Value.getString(0);
        return s;
    }
    
    public final String getArrayTreeString(JSONArray arr,int IndentLevel) {
        String ReturnString = "[\n";
        JSONNode cursor = arr.getValue();
        int NodeNumber = 0;
        while(cursor !=null) {
            ReturnString += getTreeIndent(IndentLevel + 1) +
                    "[" + Integer.toString(NodeNumber++) + "] : " +
                    getTreeValue(cursor.getValue(),IndentLevel);
            if((cursor = cursor.getNext()) != null) ReturnString += " ,";
            ReturnString += "\n";
        }
        ReturnString += getTreeIndent(IndentLevel) + "]";
        return ReturnString;
    }
    
    public final String getObjectTreeString(JSONObject obj,int IndentLevel) {
        String ReturnString = "{\n";
        JSONNode Cursor = obj.getValue();
        while(Cursor != null) {
            ReturnString += getTreeIndent(IndentLevel + 1) + ((JSONObjectNode)Cursor).getName() + " : " + getTreeValue(Cursor.getValue(),IndentLevel);
            if((Cursor = Cursor.getNext()) != null) ReturnString += " ,";
            ReturnString += "\n";
        }
        ReturnString += getTreeIndent(IndentLevel) + "}";
        return ReturnString;
    }
    
    private CustomMutableTreeNode buildNode(String Name,JSONValue Value) {
        CustomMutableTreeNode Node = new CustomMutableTreeNode(Name);
        Node.setValuePointer(Value);
        
        if(Value instanceof JSONObject) {
            JSONNode ObjectLeaf = ((JSONObject)Value).getValue();
            while(ObjectLeaf != null) {
                String ChildName = ((JSONObjectNode)ObjectLeaf).getName();
                CustomMutableTreeNode ObjectChildTree = buildNode(ChildName,ObjectLeaf.getValue());
                Node.add(ObjectChildTree);
                ObjectChildTree.setParent(Node);
                ObjectLeaf = ObjectLeaf.getNext();
            }
        } else if(Value instanceof JSONArray) {
                JSONNode ArrayLeaf = ((JSONArray)Value).getValue();
                int LeafNumber = 0;
                while(ArrayLeaf != null) {
                    CustomMutableTreeNode ArrayChildTree = buildNode("[" + Integer.toString(LeafNumber++) + "]",ArrayLeaf.getValue());
                    Node.add(ArrayChildTree);
                    ArrayChildTree.setParent(Node);
                    ArrayLeaf = ArrayLeaf.getNext();
                }
        }
        return Node;
    }
        
    /**
     * searchNode(SearchString,StartNode,Origin)
     * Search the next node whose name contains SearchString
     * 
     * @param SearchString  the string to search for
     * @param StartNode     the currently selected node
     * @param Origin        the origin of the recursion, == StartNode for the first call
     *                      used to stop the search in case the search string doesn't exist in the tree
     * @return              the node where the string is found
     */
    @SuppressWarnings("empty-statement")
   private CustomMutableTreeNode searchNode(String SearchString,CustomMutableTreeNode StartNode,CustomMutableTreeNode Origin) {
       CustomMutableTreeNode cursor = StartNode,NextSibling;
       // if there is no selection, start from the root
       if(cursor == null) cursor = TreeRoot;
       else if(cursor.getChildCount() > 0) cursor = (CustomMutableTreeNode) cursor.getFirstChild(); /* forward track */
       else if((NextSibling = (CustomMutableTreeNode)cursor.getNextSibling()) != null) cursor = NextSibling; /* track same level */
       else { /* backtrack parent */
           while(((cursor = (CustomMutableTreeNode) cursor.getParent()) != null) &&
                   ((NextSibling = (CustomMutableTreeNode)cursor.getNextSibling()) == null));
           cursor = NextSibling;
       }
       
       return (cursor == Origin) || (cursor != null && ((String)cursor.getUserObject()).toLowerCase().contains(SearchString)) ?
               cursor :
               searchNode(SearchString,cursor,Origin); // this line makes this function recursive
    }
   
    private CustomMutableTreeNode searchNode(String SearchString,CustomMutableTreeNode StartNode) {
        return searchNode(SearchString,StartNode,StartNode);
    }
    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton ButtonHideContentSearch;
    private javax.swing.JButton ButtonHideFindPanel;
    private javax.swing.JButton ButtonSearch;
    private javax.swing.JMenu ContentActions;
    private javax.swing.JButton ContentButtonSearch;
    private javax.swing.JMenuItem ContentFind;
    private javax.swing.JTextField ContentFindWhat;
    private javax.swing.JPanel ContentSplitPanel;
    private javax.swing.JMenuItem Find;
    private javax.swing.JMenuItem Info;
    private javax.swing.JTextArea JSONContent;
    private javax.swing.JTree JSONTree;
    private javax.swing.JMenuItem JumpToBegin;
    private javax.swing.JMenuItem JumpToEnd;
    private javax.swing.JLabel LabelContentFind;
    private javax.swing.JLabel LabelFind;
    private javax.swing.JMenuBar MainMenuBar;
    private javax.swing.JMenu MenuEdit;
    private javax.swing.JMenu MenuFile;
    private javax.swing.JMenuItem Open;
    private javax.swing.JPanel PanelContentFind;
    private javax.swing.JPanel PanelContents;
    private javax.swing.JPanel PanelFind;
    private javax.swing.JMenuItem Quit;
    private javax.swing.JScrollPane ScrollPaneContent;
    private javax.swing.JScrollPane ScrollPaneTree;
    private javax.swing.JSplitPane Splitter;
    private javax.swing.JTextField TextToFind;
    private javax.swing.JPanel TreeSplitPanel;
    private javax.swing.JMenuItem jMenuItem1;
    private javax.swing.JMenuItem jMenuItem2;
    private javax.swing.JMenuItem jMenuItem3;
    private javax.swing.JPopupMenu.Separator jSeparator1;
    // End of variables declaration//GEN-END:variables
}
